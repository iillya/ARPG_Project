// Copyright 2022-2024 Mickael Daniel. All Rights Reserved.

#include "BlueprintGraph/GBAK2Node_SwitchGameplayAttribute.h"

#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "EdGraphSchema_K2.h"
#include "Engine/Blueprint.h"
#include "Interfaces/IPluginManager.h"
#include "Utils/GBABlueprintLibrary.h"

UGBAK2Node_SwitchGameplayAttribute::UGBAK2Node_SwitchGameplayAttribute(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	FunctionName = TEXT("NotEqual_GameplayAttributeGameplayAttribute");
	FunctionClass = UGBABlueprintLibrary::StaticClass();
	OrphanedPinSaveMode = ESaveOrphanPinMode::SaveNone;
}

void UGBAK2Node_SwitchGameplayAttribute::CreateFunctionPin()
{
	// Set properties on the function pin
	UEdGraphPin* FunctionPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Object, FunctionClass, FunctionName);
	FunctionPin->bDefaultValueIsReadOnly = true;
	FunctionPin->bNotConnectable = true;
	FunctionPin->bHidden = true;

	const UFunction* Function = FindUField<UFunction>(FunctionClass, FunctionName);
	if (Function->HasAllFunctionFlags(FUNC_Static))
	{
		// Wire up the self to the CDO of the class if it's not us
		if (const UBlueprint* BP = GetBlueprint())
		{
			const UClass* FunctionOwnerClass = Function->GetOuterUClass();
			if (!BP->SkeletonGeneratedClass->IsChildOf(FunctionOwnerClass))
			{
				FunctionPin->DefaultObject = FunctionOwnerClass->GetDefaultObject();
			}
		}
	}
}

void UGBAK2Node_SwitchGameplayAttribute::PostLoad()
{
	Super::PostLoad();
	if (UEdGraphPin* FunctionPin = FindPin(FunctionName))
	{
		FunctionPin->DefaultObject = FunctionClass->GetDefaultObject();
	}
}

void UGBAK2Node_SwitchGameplayAttribute::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
	bool bIsDirty = false;
	const FName PropertyName = PropertyChangedEvent.Property ? PropertyChangedEvent.Property->GetFName() : NAME_None;
	if (PropertyName == GET_MEMBER_NAME_CHECKED(UGBAK2Node_SwitchGameplayAttribute, PinAttributes) || PropertyName == FName("AttributeName"))
	{
		bIsDirty = true;
	}

	if (bIsDirty)
	{
		ReconstructNode();
		GetGraph()->NotifyGraphChanged();
	}
	Super::PostEditChangeProperty(PropertyChangedEvent);
}

FText UGBAK2Node_SwitchGameplayAttribute::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return NSLOCTEXT("K2Node", "ASBP_Switch_GameplayAttribute", "Switch on Gameplay Attribute");
}

FText UGBAK2Node_SwitchGameplayAttribute::GetTooltipText() const
{
	return NSLOCTEXT("K2Node", "ASBP_SwitchGameplayAttribute_ToolTip", "Selects an output that matches the input gameplay attribute value");
}

void UGBAK2Node_SwitchGameplayAttribute::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	// Is GAS Companion currently enabled ?
	//
	// If so, early return here, this will prevent addition of this K2_Node in context menu
	//
	// GAS Companion has already a Switch On Gameplay Attribute node. We only want to expose the present class
	// if GAS Companion is not available (and prevent duplication of this node in context menu)
	if (IsGasCompanionPluginEnabled())
	{
		return;
	}

	// actions get registered under specific object-keys; the idea is that
	// actions might have to be updated (or deleted) if their object-key is
	// mutated (or removed)... here we use the node's class (so if the node
	// type disappears, then the action should go with it)
	const UClass* ActionKey = GetClass();
	// to keep from needlessly instantiating a UBlueprintNodeSpawner, first
	// check to make sure that the registrar is looking for actions of this type
	// (could be regenerating actions for a specific asset, and therefore the
	// registrar would only accept actions corresponding to that asset)
	if (ActionRegistrar.IsOpenForRegistration(ActionKey))
	{
		UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
		check(NodeSpawner != nullptr);

		ActionRegistrar.AddBlueprintAction(ActionKey, NodeSpawner);
	}
}

void UGBAK2Node_SwitchGameplayAttribute::CreateSelectionPin()
{
	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();
	UEdGraphPin* Pin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Struct, FGameplayAttribute::StaticStruct(), TEXT("Selection"));
	K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(Pin);
}

FEdGraphPinType UGBAK2Node_SwitchGameplayAttribute::GetPinType() const
{
	FEdGraphPinType PinType;
	PinType.PinCategory = UEdGraphSchema_K2::PC_Struct;
	PinType.PinSubCategoryObject = FGameplayAttribute::StaticStruct();
	return PinType;
}

FEdGraphPinType UGBAK2Node_SwitchGameplayAttribute::GetInnerCaseType() const
{
	// This type should match the second argument of UGBABlueprintLibrary::NotEqual_GameplayAttributeGameplayAttribute !
	FEdGraphPinType PinType;
	PinType.PinCategory = UEdGraphSchema_K2::PC_String;
	return PinType;
}

FName UGBAK2Node_SwitchGameplayAttribute::GetPinNameGivenIndex(const int32 Index) const
{
	check(Index);
	return PinNames[Index];
}

void UGBAK2Node_SwitchGameplayAttribute::CreateCasePins()
{
	while (PinAttributes.Num() > PinNames.Num())
	{
		const FName PinName = GetUniquePinName();
		PinNames.Add(PinName);
	}

	if (PinNames.Num() > PinAttributes.Num())
	{
		PinNames.SetNum(PinAttributes.Num());
	}

	for (int32 Index = 0; Index < PinAttributes.Num(); ++Index)
	{
		if (PinAttributes[Index].IsValid())
		{
			PinNames[Index] = *PinAttributes[Index].GetName();
		}
		else
		{
			PinNames[Index] = GetUniquePinName();
		}

		UEdGraphPin* NewPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, PinNames[Index]);
		NewPin->bAllowFriendlyName = false;
		if (PinAttributes[Index].IsValid())
		{
			FGameplayAttribute Attribute = PinAttributes[Index];
			FString FriendlyName = Attribute.GetAttributeSetClass()->GetName() + "." + Attribute.GetName();
			NewPin->PinFriendlyName = FText::FromString(FriendlyName);
		}
		else
		{
			NewPin->PinFriendlyName = FText::FromName(PinNames[Index]);
		}
	}
}

FName UGBAK2Node_SwitchGameplayAttribute::GetUniquePinName()
{
	FName NewPinName;
	int32 Index = 0;
	while (true)
	{
		NewPinName = *FString::Printf(TEXT("Case_%d"), Index++);
		if (!FindPin(NewPinName))
		{
			break;
		}
	}
	return NewPinName;
}

void UGBAK2Node_SwitchGameplayAttribute::AddPinToSwitchNode()
{
	const FName PinName = GetUniquePinName();
	PinNames.Add(PinName);

	UEdGraphPin* NewPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, PinName);
	NewPin->bAllowFriendlyName = false;
	NewPin->PinFriendlyName = FText::FromName(PinName);

	if (PinAttributes.Num() < PinNames.Num())
	{
		PinAttributes.Add(FGameplayAttribute());
	}
}

void UGBAK2Node_SwitchGameplayAttribute::RemovePin(UEdGraphPin* TargetPin)
{
	checkSlow(TargetPin);

	const FName PinName = TargetPin->PinName;
	// Clean-up pin name array
	const int32 Index = PinNames.IndexOfByKey(PinName);
	if (Index >= 0)
	{
		if (Index < PinAttributes.Num())
		{
			PinAttributes.RemoveAt(Index);
		}
		PinNames.RemoveAt(Index);
	}
}

bool UGBAK2Node_SwitchGameplayAttribute::IsGasCompanionPluginEnabled()
{
	if (const TSharedPtr<IPlugin> Plugin = IPluginManager::Get().FindPlugin(TEXT("GASCompanion")))
	{
		return Plugin->IsEnabled();
	}
	
	return false;
}
